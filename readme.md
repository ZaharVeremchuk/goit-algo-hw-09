<h1>Порівняння ефективності </h1>
<p> Обидва алгоритми працюють з різною ефективністю. Жадібний алгоритм зазвичай швидший, оскільки він приймає рішення на кожному кроці, не враховуючи попередні. Проте, він не завжди знаходить оптимальне рішення, особливо для наборів монет, де жадібний вибір не призводить до мінімальної кількості монет.

Динамічне програмування, хоча й потребує більше часу для обчислень, гарантує знаходження оптимального рішення. Воно зберігає проміжні результати, щоб уникнути повторних обчислень, що робить його ефективним для великих сум.

У випадку великих сум, динамічне програмування може виявитися більш ефективним, оскільки час, витрачений на пошук оптимального рішення, може бути меншим за втрати від використання більшої кількості монет, ніж необхідно.</p>

**Результат, час виконная при сумі 113**<br>
<code>
Жадібний алгоритм (середній час за 10000 виконань): 0.008440 сек <br>
Динамічне програмування (середній час за 10000 виконань): 1.344771 сек
</code>

**Результат, час виконная при сумі 1000**<br>

<code>
Жадібний алгоритм (середній час за 10000 виконань): 0.006284 сек <br>
Динамічне програмування (середній час за 10000 виконань): 12.652409 сек
</code>